<?php

/**
 * Regression module
 *
 * @file
 *   Main module file.
 */

define('REGRESSION_ENTRY_STATE_BROKEN',            -2);
define('REGRESSION_ENTRY_STATE_REGRESSION',        -1);
define('REGRESSION_ENTRY_STATE_CANDIDATE',          0);
define('REGRESSION_ENTRY_STATE_APPROVED',           1);
define('REGRESSION_EMAIL_DEFAULT_REGRESSION_TITLE', 'Regression module detected potential page regression');
define('REGRESSION_EMAIL_DEFAULT_REGRESSION_BODY',  "Welcome,\n\nPage [regression:page-url] of menu path [regression:menu-path] has changed on [regression:datetime] and you are allowed to [regression:take-action-url] made.\n\nDifference between last working version of the page:\n\n[regression:difference]\n\nYou may also [regression:settings-url].\n\nThank you!");

include_once 'regression.features.inc';
require_once 'includes/regression.regression_entry.inc';
require_once 'includes/regression.regression_revision.inc';

/**
 * @TODO:
 *   [X] convert Drupal html pages into text and save into entity
 *   [X] duplicates entities are ignored
 *   [X] entities are grouped by the menu callback and page arguments
 *   [ ] send notications about the changes and post the one-time login link (to approve the changes)
 *   [ ] user selects the following options:
 *     [X] Approve the change and set the page as default
 *     [ ] Mark that change as dynamic (ignore it in the future)
 *     [X] Mark as regression
 *     [X] Mark as broken
 *   [X] description of approval or disapproval can be configured as required or not (fieldable entity)
 *   [X] description of approval or disapproval can contain
 *     [X] description
 *     [X] priority (minor, major, blocker)
 *     [X] module name (optional)
 *     [X] URL for bug tracker
 *     [X] assignee (responsible responsible)
 *   [X] create the view list with all regressions, blockers and broken pages
 *     [X] show the date, when last time it was working
 *   [X] configure e-mail content in admin panel
 *   [ ] when content is marked as dynamic, find the right regex/pattern to ignore similar change in the future
 *   [X] dynamic page arguments can be configured as dynamic, so threated as the same page
 *   [ ] add drush command to list all regressions, blockers and broken pages (one per line, return empty content if none)
 *
 */

/**
 * Include for the Regression feature.
 */
// include_once 'regression.features.inc';

/**
 * Implements hook_init().
 */
function regression_init() {
  $path = drupal_get_path('module', 'regression');
}

/**
 * Implements hook_menu().
 */
function regression_menu() {
  regression_regression_entry_menu($menu);
  regression_regression_revision_menu($menu);
  
  $menu['admin/config/regression'] = array(
    'file'             => 'includes/regression.admin.paths.inc',
    'title'            => 'Regression settings',
    'position'         => 'left',
    'weight'           => -20,
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_paths_form'),
    'access arguments' => array('regression administration'),
    'expanded'         => TRUE,
  );

  $menu['admin/config/regression/status'] = array(
    'type'             => MENU_NORMAL_ITEM | MENU_LOCAL_TASK,
    'file'             => 'includes/regression.admin.status.inc',
    'title'            => 'Regression status',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_status_form'),
    'access arguments' => array('regression administration'),
    'weight'           => -5,
  );
  
  $menu['admin/config/regression/paths'] = array(
    'type'             => MENU_NORMAL_ITEM | MENU_DEFAULT_LOCAL_TASK,
    'file'             => 'includes/regression.admin.paths.inc',
    'title'            => 'Paths',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_paths_form'),
    'access arguments' => array('regression administration'),
    'weight'           => -5,
  );
  
  $menu['admin/config/regression/advanced'] = array(
    'type'             => MENU_NORMAL_ITEM | MENU_LOCAL_TASK,
    'file'             => 'includes/regression.admin.advanced.inc',
    'title'            => 'Advanced settings',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_advanced_form'),
    'access arguments' => array('regression administration'),
    'weight'           => -4,
  );


  $menu['admin/config/regression/paths/add'] = array(
    'file'             => 'includes/regression.admin.paths.edit.inc',
    'title'            => 'Adding path for regression, step 1/2',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_paths_add_form'),
    'access arguments' => array('regression administration'),
  );
  
  $menu['admin/config/regression/paths/default'] = array(
    'type'             => MENU_NORMAL_ITEM | MENU_LOCAL_TASK,
    'file'             => 'includes/regression.admin.paths.edit.inc',
    'title'            => 'Default settings',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_paths_edit_form'),
    'access arguments' => array('regression administration'),
  );
  
  $menu['admin/config/regression/paths/%'] = array(
    'file'             => 'includes/regression.admin.paths.edit.inc',
    'title'            => 'Editing regression path settings',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_paths_edit_form'),
    'access arguments' => array('regression administration'),
  );
  
  $menu['admin/config/regression/paths/switch'] = array(
    'type'             => MENU_CALLBACK,
    'title'            => t('Switch regression path on/off'),
    'page callback'    => 'regression_switch_path_configuration',
    'access arguments' => array('regression administration'),
   );
  
  $menu['admin/config/regression/paths/%/remove'] = array(
    'file'             => 'includes/regression.admin.path.remove.inc',
    'title'            => 'Remove menu path from regression testing',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_path_remove_form'),
    'access arguments' => array('regression administration'),
   );
  
  $menu['admin/config/regression/review/%'] = array(
    'file'             => 'includes/regression.admin.take.action.inc',
    'title'            => 'Revision review',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('regression_take_action_form'),
    'access arguments' => array('regression administration'),
  );
  
  $menu['regression/module-autocomplete'] = array(
    'type'             => MENU_CALLBACK,
    'path'             => 'regression/module-autocomplete',
    'title'            => t('Module Autocomplete'),
    'page callback'    => 'regression_module_autocomplete',
    'access arguments' => array('regression administration'),
   );
  
  return $menu;
}

/**
 * Retrieve a pipe delimited string of autocomplete suggestions for enabled modules.
 */
function regression_module_autocomplete($string) {
  $string = check_plain($string);
  $matches = array();
  $result = db_query_range("SELECT name FROM {system} WHERE LOWER(name) LIKE LOWER('$string%')", 0, 15);
  while ($module = $result->fetchAssoc()) {
    $matches[$module['name']] = check_plain($module['name']);
  }
  print drupal_json_output($matches);
  exit();
}

/**
 * Returns list of configured pages including their configuration.
 */
function regression_paths_configured() {
  
  $records = db_select('regression_path_configuration')
    ->fields('regression_path_configuration', array('pid', 'path', 'enabled'))
    ->condition('visible', '1')
    ->orderBy('enabled', 'DESC')
    ->orderBy('path')
    ->execute()
    ->fetchAll();

  foreach ($records as &$record) {
    $record = (array)$record;
    $record['features'] = '';
  }
  
  return $records;
}

/**
 * Returns statuses of regression entries.
 */
function regression_status() {
  
  $select = db_select('regression_entry', 're');
  
  $select->leftJoin('regression_path_configuration', 'pc', 're.path = pc.path');
  $select->leftJoin('regression_revision', 'last_revision', 'last_revision.entry_id = re.pid AND last_revision.revision_id = re.current_revision_id');
  $select->leftJoin('regression_revision', 'last_working_revision', 'last_working_revision.entry_id = re.pid AND last_working_revision.revision_id = re.current_working_revision_id');
  
  $records = $select
    ->fields('re', array('pid', 'path', 'state', 'current_working_revision_id', 'current_working_revision_pid', 'current_revision_id', 'current_revision_pid',
      'related_module_name', 'assignee', 'priority'))
    ->fields('last_revision', array('pid', 'uri', 'path_args', 'revision_id'))
    ->fields('last_working_revision', array('pid', 'revision_id', 'updated'))
    ->condition('pc.visible', '1')
    ->condition('pc.enabled', '1')
    ->condition('pc.ready',   '1')
    ->orderBy('path')
    ->execute()
    ->fetchAll();

  foreach ($records as &$record) {
    $record = (array)$record;
  }
  
  return $records;
}

/**
 * Implements hook_entity_info().
 */
function regression_entity_info() {
  $info = array();
  regression_regression_entry_entity_info($info);
  regression_regression_revision_entity_info($info);
  return $info;
}

/**
 * Switch path configuration record on/off.
 * @param number $entry_pid
 */
function regression_switch_path_configuration($pid) {
  db_update('regression_path_configuration')
    ->condition('pid', $pid)
    ->expression('enabled', '(CASE WHEN enabled = 1 THEN 0 ELSE 1 END)')
    ->execute();
  
  drupal_goto('admin/config/regression/paths');
}

/**
 * Returns regression path configuration array.
 * 
 * @param string $path_pattern
 *   Menu path pattern.
 * @param boolean $include_default_settings
 *   Indicates if configuration should be merged with default settings.
 * @return array
 */
function regression_get_path_configuration($path_pattern, $include_default_settings = FALSE) {
  $record = db_select('regression_path_configuration', 'RC')
    ->fields('RC', array('settings', 'enabled'))
    ->condition('path', $path_pattern)
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();
  
  $settings = json_decode($record['settings'], TRUE);
  
  if (isset($settings['notifications_email_recipients'])) {
    
    $settings['notifications_email_recipients'] =
      explode("\n", $settings['notifications_email_recipients']);
    
    // Removing empty emails.
    foreach ($settings['notifications_email_recipients'] as $index => &$recipient) {
      $recipient = trim($recipient);
      if (empty($recipient)) {
        unset($settings['notifications_email_recipients'][$index]);
      }
    }
  }
  
  if ($include_default_settings && $path_pattern !== '__default') {
    
    $parent_settings = regression_get_path_configuration('__default');  
    
    // Merging configuration.
    
    static $variable_names = array(
      'notifications_email_send_as_html'     => FALSE,
      'notifications_email_regression_title' => REGRESSION_EMAIL_DEFAULT_REGRESSION_TITLE,
      'notifications_email_regression_body'  => REGRESSION_EMAIL_DEFAULT_REGRESSION_BODY,
    );

    foreach ($variable_names as $name => $default_value) {
      $settings[$name] =
        !empty($parent_settings[$name]) ?
        $parent_settings[$name] : $default_value;
    }
     
    if (empty($settings['override_default_notifications_email_recipients'])) {
      // Merging email recipients.
      
      $settings['notifications_email_recipients'] = array_merge(
        isset($settings['notifications_email_recipients']) ? $settings['notifications_email_recipients'] : array(),
        isset($parent_settings['notifications_email_recipients']) ? $parent_settings['notifications_email_recipients'] : array()
      );
    }
  }
  
  $settings['enabled'] = $record['enabled'];
  
  return $settings;
}

/**
 * Creates or updates regression path configuration.
 * 
 * @param string $path_pattern
 *   Menu path pattern.
 * @param array $configuration
 *   Initial configuration array.
 */
function regression_set_path_configuration($path_pattern, $configuration) {
  $records = db_select('regression_path_configuration')
    ->fields('regression_path_configuration', array('pid'))
    ->condition('path', $path_pattern)
    ->range(0, 1)
    ->execute()
    ->fetchField();
  
  if ($records) {
    // Path is already configured.
    $query = db_update('regression_path_configuration');
    $query->condition('path', $path_pattern);
  }
  else {
    // Path not yet configured.
    $query = db_insert('regression_path_configuration');
  }
  
  // Checking if path is ready to be tested for regression.
  $ready = !empty($configuration['key_segments_enabled']);
  
  $query->fields(array(
    'path'     => $path_pattern,
    'settings' => json_encode($configuration),
    'enabled'  => '1',
    'ready'    => $ready ? '1' : '0',
    'visible'  => $path_pattern == '__default' ? '0' : '1',
    'created'  => REQUEST_TIME,
  )) ->execute();
    
  return TRUE;
}

/**
 * Returns key built using path configuration.
 */
function regression_build_key($configuration) {
  
  $key = array();
  
  if (!isset($configuration['key_segments_enabled'])) {
    // No key segments enabled
    $key[] = 'None';
  }
  else {
  
    $key_segments = regression_keys();
    
    foreach ($configuration['key_segments_enabled'] as $name => $enabled) {
      
      if (!$enabled)
        continue;
      
      $key[] = call_user_func_array($key_segments[$name]['callback'], array(
        isset($configuration['key_segments'][$name]) ? $configuration['key_segments'][$name] : array()
      ));
    }
  }
  
  return sha1(implode('$', $key));
}

/**
 * Hook that provides regression keys to use with single path configuration.
 */
function regression_keys() {
  $keys = array(
    'builtin-domain' => array(
      'title'    => t('Domain'),
      'callback' => 'regression_regression_key_domain',
      'default'  => TRUE,
    ),
    'builtin-site-name' => array(
      'title'    => t('Site name'),
      'callback' => 'regression_regression_key_site_name',
      'default'  => TRUE,
    ),
    'builtin-page-path' => array(
      'title'    => t('Menu path'),
      'callback' => 'regression_regression_key_menu_path',
      'default'  => TRUE,
    ),
    'builtin-page-arguments' => array(
      'title'    => t('Page arguments'),
      'callback' => 'regression_regression_key_page_arguments',
      'default'  => TRUE,
      'form'     => 'regression_paths_edit_page_arguments_form',
    ),
    'builtin-page-callback-name' => array(
      'title'    => t('Menu callback name'),
      'callback' => 'regression_regression_key_menu_callback_name',
      'default'  => TRUE,
    ),
    'builtin-user-roles-ids' => array(
      'title'    => t('User roles (IDs)'),
      'callback' => 'regression_regression_key_user_roles_ids',
      'default'  => TRUE,
    ),
  );
  
  return array_merge($keys, module_invoke_all('regression_keys'));
}

/**
 * Key segment callback of "Has unique domain".
 * @param array $settings
 *   Key segment settings.
 * @return string
 *   Stringified version of the key.
 */
function regression_regression_key_domain($settings) {
  if (!isset($_SERVER['HTTP_HOST'])) {
    return 'Unknown';
  }
  
  return preg_replace('`^www.`', '', $_SERVER['HTTP_HOST']);
}

/**
 * Key segment callback of "Has unique site name".
 * @param array $settings
 *   Key segment settings.
 * @return string
 *   Stringified version of the key.
 */
function regression_regression_key_site_name($settings) {
  return variable_get('site_name');
}

/**
 * Key segment callback of "Has unique menu path".
 * @param array $settings
 *   Key segment settings.
 * @return string
 *   Stringified version of the key.
 */
function regression_regression_key_menu_path($settings) {
  $menu_item = menu_get_item(request_path());
  return $menu_item['path'];
}

/**
 * Key segment callback of "Has unique page arguments".
 * @param array $settings
 *   Key segment settings.
 * @return string
 *   Stringified version of the key.
 */
function regression_regression_key_page_arguments($settings, $check_ignores = TRUE) {
  
  $menu_item              = menu_get_item(request_path());
  $menu_path              = $menu_item['path'];
  $menu_path_segments     = explode('/', $menu_path);
  $num_menu_path_segments = count($menu_path_segments);
  $num_args               = count(arg());
  $result                 = array();
  $arg_counter            = 0;
  
  for ($arg_i = 0; $arg_i < $num_args; ++$arg_i) {
    
    if ($arg_i > $num_menu_path_segments - 1) {
      // No more custom parameters
      $result[] = arg($arg_i);
    }
    elseif ($menu_path_segments[$arg_i] == '%') {
        
      // Checking if arguments isn't ingored.
      if (!$check_ignores || isset($settings['uniques'][$arg_counter])) {
        $result[] = arg($arg_i);
      }
      
      ++$arg_counter;
    }
  }
  
  return implode(', ', $result);
}

/**
 * Key segment callback of "Has unique menu callback name".
 * @param array $settings
 *   Key segment settings.
 * @return string
 *   Stringified version of the key.
 */
function regression_regression_key_menu_callback_name($settings) {
  $menu_item = menu_get_item(request_path());
  return $menu_item['page_callback'];
}

function regression_regression_key_user_roles_ids($settings) {
  global $user;
  return implode(',', $user->roles);
}

/**
 * Implements hook_replacement_patterns_list().
 */
function regression_replacement_patterns_list(RegressionRevision $revision = NULL) {
  // [regression:datetime]
  $patterns['regression:datetime'] = array(
    'title'   => t('Date and time the page has changed.'),
    'example' => '20/11/' . date('Y H:i:s'),
  );
  
  if ($revision !== NULL) {
    $patterns['regression:datetime']['value_text'] = date('d/m/Y H:i:s', $revision -> updated);
  }

  // [regression:page-url]
  $patterns['regression:page-url'] = array(
    'title'   => t('URL of the page that has changed.'),
    'example' => l('node/30/edit', 'node/30/edit'),
  );

  if ($revision !== NULL) {
    $patterns['regression:page-url']['value_html'] = l($revision->uri, $revision->uri);
    $patterns['regression:page-url']['value_text'] = $revision->uri;
  }

  // [regression:menu-path]
  $patterns['regression:menu-path'] = array(
    'title'   => t('Menu path pattern of the page that has changes.'),
    'example' => 'node/%/edit',
  );

  if ($revision !== NULL) {
    $patterns['regression:menu-path']['value_text'] = $revision->path;
  }
  
  // [regression:take-action-url]
  $patterns['regression:take-action-url'] = array(
    'title'   => t('URL to the page to approve od decline changes.'),
    'example' => l(t('approve or disapprove changes'), 'admin/config/regression/review/1'),
  );

  if ($revision !== NULL) {
    $patterns['regression:take-action-url']['value_html'] = l(t('approve or disapprove changes'), 'admin/config/regression/review/' . $revision->pid);
    $patterns['regression:take-action-url']['value_text'] = t('approve or disapprove changes (!url)', array('!url' => 'admin/config/regression/review/' . $revision->pid));
  }

  // [regression:settings-url]
  $patterns['regression:settings-url'] = array(
    'title'   => t('URL to change path configuration.'),
    'example' => l(t('change configuration for this page'), 'admin/config/regression/paths/' . base64_encode('node/%/edit')),
  );

  if ($revision !== NULL) {
    $patterns['regression:settings-url']['value_html'] = l(t('change menu path configuration'), 'admin/config/regression/paths/' . base64_encode($revision->path));
    $patterns['regression:settings-url']['value_text'] = t('change menu path configuration (!url)', array('!url' => 'admin/config/regression/paths/' . base64_encode($revision->path)));
  }

  // [regression:difference]
  $example_changes = '<span style="color:rgba(0,0,0,0.5)">hello </span><span style="color:#000;background-color:#bf6;padding:2px 5px;">Drupal</span><span style="color:rgba(0,0,0,0.5)"> world</span><span style="color:#000;background-color:#f85;padding:2px 5px;">.</span><span style="color:#000;background-color:#bf6;padding:2px 5px;">!</span>';

  $patterns['regression:difference'] = array(
    'title'   => t('Visualization of difference between last working version of the page'),
    'example' => $example_changes,
  );

  if ($revision !== NULL) {
    
    $css_diff = 'color:rgba(0,0,0,0.5);-ms-word-break: break-all;word-break: break-all;word-break: break-word;-webkit-hyphens: auto;-moz-hyphens: auto;hyphens:auto; border:2px solid #ff6;padding:12px;margin:4px 8px;background:#ffa';
    
    $entry = regression_entry_load($revision->entry_id);
    
    $previous_revision = regression_revision_load($entry->current_working_revision_pid);
    
    $patterns['regression:difference']['value_html'] = '<div style="' . $css_diff . '">' . regression_diff_revisions($previous_revision === FALSE ? NULL : $previous_revision, $revision) . '</div>';
    $patterns['regression:difference']['value_text'] =
      "--------------------------------------------------------------------------------\n" .
      regression_diff_revisions($previous_revision === FALSE ? NULL : $previous_revision, $revision, FALSE) .
      "\n--------------------------------------------------------------------------------\n";
  }
  
  drupal_alter('replacement_patterns_list', $patterns, $revision);
  
  return $patterns;
}

/**
 * Replaces tokens in content using revision data.  
 * @param RegressionRevision $revision
 *   Revision of which data should be used for replacements.
 * @param string $content
 *   Template
 * @param boolean $use_html
 *   Indicates whether replecements may use HTML output.
 * @return string
 *   Resulting content
 */
function regression_replacement_patterns_replace(RegressionRevision $revision, $content, $use_html = TRUE) {
  // Populating patterns.
  $patterns = regression_replacement_patterns_list($revision);
  
  foreach ($patterns as $pattern => $options) {
    if (isset($options['value_text']) || isset($options['value_html'])) {
      // Replacing pattern
      
      if ($use_html) {
        $value = isset($options['value_html']) ? $options['value_html'] : $options['value_text'];
      }
      else {
        if (!isset($options['value_text'])) {
          // Converting HTML into plain text
          $value = drupal_html_to_text($options['value_html']);
        }
        else {
          $value = $use_html && isset($options['value_html']) ? $options['value_html'] : $options['value_text']; 
        }
      }
          
      $content = str_replace('[' . $pattern . ']', $value, $content);
    }
  }
  
  return $content;
}

/**
 * Sends e-mail to configured recipients to take action for changes detected.
 * @param RegressionRevision $old_revision
 *   Previous revision
 * @param RegressionRevision $new_revision
 *   Newly saved revision
 */
function regression_revision_send_take_action_email(RegressionEntry $entry, RegressionRevision $old_revision, RegressionRevision $new_revision) {
  
  // Populating variables.
  
  $revision_old_id   = $old_revision->revision_id;
  $revision_old_date = date('Y-m-d H:i:s', $old_revision->updated);
  
  $revision_new_id   = $new_revision->revision_id;
  $revision_new_date = date('Y-m-d H:i:s', $new_revision->updated);
  
  $settings          = regression_get_path_configuration($entry->path, TRUE);
  
  $recipients        = $settings['notifications_email_recipients'];
  $template_send_as_html = $settings['notifications_email_send_as_html'];
  $template_title    = $settings['notifications_email_regression_title'];
  $template_body     = $settings['notifications_email_regression_body'];

  $css_body          = 'padding: 12px;';
  
  $title             = regression_replacement_patterns_replace($new_revision, $template_title);
  
  if ($template_send_as_html) {
    $body            = '<div style="' . $css_body . '">' . regression_replacement_patterns_replace($new_revision, $template_body) . '</div>';
    
    // Newlines become a "display:block".
    $body              = str_replace("\n", "<span style='display:block;'></span>\n", $body);
  }
  else {
    $body            = regression_replacement_patterns_replace($new_revision, $template_body, FALSE);
  }
  
  $module            = 'regression';
  $key               = 'a93kf82kf';
  $language          = language_default();
  $params            = array();
  $from              = NULL;

  foreach ($recipients as $email) {
    
    // Creating e-mail message.
    $send     = FALSE;
    $message  = drupal_mail($module, $key, $email, $language, $params, $from, $send);
  
    $message['subject'] = $title;
    $message['body']    = array();
    $message['body'][]  = $body;

    // Retrieve the responsible implementation for this message.
    $system = drupal_mail_system($module, $key);
  
    // Format the message body.
    $message = $system->format($message);
  
    // Send e-mail.
    $message['result'] = $system->mail($message);
  }  
}

/**
 * Implements hook_help().
 */
function regression_help($path, $args) {
  if ($path == 'admin/help#regression') {
    $out = '<p>' . t('Regression module help.') . '</p>';
    return $out;
  }
}

/**
 * Field Api extra fields handler
 */
function regression_field_extra_fields() {
  $return = array();
  regression_regression_entry_field_extra_fields($return);
  regression_regression_revision_field_extra_fields($return);
  return $return;
}

/**
* Implements hook_entity_property_info_alter().
*/
function regression_entity_property_info_alter(&$info) {
  regression_regression_entry_entity_property_info_alter($info);
  regression_regression_revision_entity_property_info_alter($info);
}

/**
 * Implements hook_permission().
 */
function regression_permission() {
  return array(
    'regression administration' => array(
      'title' => t('Administer Regression module'),
      'description' => t('Perform administration tasks for Regression module.'),
    ),
  );
}

/**
 * Implements hook_flush_caches().
 */
function regression_flush_caches() {
  return array('cache_regression');
}

/**
 * Implements hook_exit().
 */
function regression_exit() {
  
  try {

  if ($_POST) {
    return;
  }
  
  // Here we are skipping processing for specified content types.
  $header         = drupal_get_http_header('content-type');   
  $ignore_formats = array('xml', 'javascript', 'json', 'plain', 'image', 'application', 'csv', 'x-comma-separated-values');
  foreach ($ignore_formats as $format) {
    if (strstr($header, $format)) {
      // Content type ignored, returning from the function.
      //return;
    }
  }
  
  $menu_item          = menu_get_item(request_path());
  
  $menu_path          = $menu_item['path'];
  $menu_args          = $menu_item['page_arguments'];
  $path_configuration = regression_get_path_configuration($menu_path, TRUE);
  
  if (!$path_configuration['enabled']) {
    // Page not added to regression testing, returning from the function.
    return;
  }
  
  // Building key from path settings.
  $key = regression_build_key($path_configuration);
  
  $menu_callback = $menu_item['page_callback'];
  $site_name     = variable_get('site_name');
  
  $html = ob_get_contents();
  $text = html_entity_decode(html2txt_convert($html)->text);
  
  // Removing non-ASCII characters.
  $text = iconv("UTF-8", "ASCII//IGNORE", $text);
  
  // Starting database transaction.
  $transaction = db_transaction();
  
  // Creating or retrieving regression entry if already exists for a given key.
  $query = new EntityFieldQuery;
  $entry = reset($query
    ->entityCondition('entity_type', 'regression_entry')
    ->propertyCondition('key_hash', $key)
    ->range(0, 1)
    ->execute());
  
  if ($entry === FALSE) {
    // No regression entry available for the page path, we will create new
    // regression entry and also a new revision for that entry.
    $entry = new RegressionEntry;
    $entry->path                         = $menu_path;
    $entry->state                        = REGRESSION_ENTRY_STATE_CANDIDATE;
    $entry->key_hash                     = $key;
    $entry->current_revision_id          = NULL;
    $entry->current_revision_pid         = NULL;
    $entry->current_working_revision_id  = NULL;
    $entry->current_working_revision_pid = NULL;
    $entry->created                      = REQUEST_TIME;
    
    // Creating initial revision for the entry.
    $revision = new RegressionRevision;
    $revision->created                  = REQUEST_TIME;
  }
  else {
    // We found related regression entry. Now we are searching if there is
    // already existing revision with the same content.
    
    // Loading entry entity.
    $entry = reset(entity_load('regression_entry', array_keys($entry)));
    
    $query = new EntityFieldQuery;
    $revision = reset($query
      ->entityCondition('entity_type', 'regression_revision')
      ->propertyCondition('entry_id', $entry->pid)
      ->propertyCondition('parser_value_plain_text', $text)
      ->range(0, 1)
      ->execute());
    
    if ($revision === FALSE) {
      // No matching revision found, creating a new one.
      $revision = new RegressionRevision;
      $revision->created = REQUEST_TIME;
      
      // Incrementing last revision number by one.
      $revision->revision_id =
        db_select('regression_revision')
          ->fields('regression_revision', array('revision_id'))
          ->condition('path', $menu_path)
          ->condition('entry_id', $entry->pid)
          ->orderBy('revision_id', 'DESC')
          ->range(0, 1)
          ->execute()
          ->fetchField() + 1;
      
      $entry->state = REGRESSION_ENTRY_STATE_CANDIDATE;
    }
    else {
      // We found matching revision. We'll use it when setting current revision
      // id.
      
      // Loading revision entity.
      $revision = reset(entity_load('regression_revision', array_keys($revision)));
      
      if ($revision->revision_id !== $entry->current_working_revision_id) {
        $entry->state = REGRESSION_ENTRY_STATE_CANDIDATE;
      }
    }
  }
  
  $last_entry_revision_id            = $entry->current_revision_id;
  $last_entry_revision_pid           = $entry->current_revision_pid;
  $last_working_entry_revision_id    = $entry->current_working_revision_id;
  $last_working_entry_revision_pid   = $entry->current_working_revision_pid;
  
  // Changing current revision id for the entry.
  // Note that this doesn't affect the current working revision id.
  $entry->current_revision_id        = $revision->revision_id;
  
  $revision->updated                 = REQUEST_TIME;
  $revision->path                    = $menu_path;
  $revision->path_args               = regression_regression_key_page_arguments(regression_get_path_configuration($menu_path), FALSE);
  $revision->parser_value_html       = $html;
  $revision->parser_value_plain_text = $text;
  $revision->uri                     = request_path();
  
  module_invoke_all('regression_build_revision', $revision);
  
  // Saving regression entry entity.
  if ($entry->save() == FALSE) {
    // Can't save entity, rollbacking database transaction.
    $transaction -> rollback();
    throw new Exception("Can't save regression entry");
  }
  
  $revision->entry_id = $entry->pid;

  if ($revision->revision_id === NULL
      || ($last_working_entry_revision_id !== $revision->revision_id
        && $last_entry_revision_id !== $revision->revision_id)) {
    // Revision has changed. Performing diff.
    
    if ($last_working_entry_revision_id !== NULL) {
      
      // There is already a last working revision.
      $previous_working_revision = regression_revision_load($last_working_entry_revision_pid);
    }
    else {
      // There is no last working revision yet, simulating empty content.
      $previous_working_revision = new RegressionRevision;
      $previous_working_revision->parser_value_plain_text = '';
    }
    
    if ($previous_working_revision->parser_value_plain_text === $text) {
      // No changes detected. Nothing to do.
    }
    else {
      // Changes detected.
      
      // Clearing previous revision's text diff.
      // @COMMENTED OUT
      // $previous_working_revision->parser_value_plain_text_diff = NULL;
  
      // Saving previous regression revision.
      if ($last_working_entry_revision_id !== NULL && $previous_working_revision->save() == FALSE) {
        // Can't save entity, rollbacking database transaction.
        $transaction -> rollback();
        throw new Exception("Can't save previous regression revision");
      }
      
      $revision->previous_revision_id  = $last_entry_revision_id;
      $revision->previous_revision_pid = $last_entry_revision_pid; 
      
      $send_email = array($entry, $previous_working_revision, $revision);
    }
  }
  
  // Saving regression revision entity.
  if ($revision->save() == FALSE) {
    // Can't save entity, rollbacking database transaction.
    $transaction->rollback();
    throw new Exception("Can't save regression revision");
  }

  $entry->current_revision_pid       = $revision->pid;
  
  // Saving regression entity second time to apply revision pid.
  if ($entry->save() == FALSE) {
    // Can't save entity, rollbacking database transaction.
    $transaction->rollback();
    throw new Exception("Can't save regression entry");
  }
  
  if (isset($send_email)) {
    call_user_func_array('regression_revision_send_take_action_email', $send_email);
  }
  
  }
  catch (PDOException $err) {
    $transaction->rollback();
    var_dump ($err->getMessage());
    exit;
  }
}

/**
 * Renders diff in html format.
 * @param string $opcode
 * @param string $from
 * @param number $from_offset
 * @param number $from_len
 */
function regression_render_diff_opcode_html($opcode, $from, $from_offset, $from_len) {
  
  $css_txt = '';
  $css_del = 'color:#000;background-color:#f85;padding:1px 1px;';
  $css_ins = 'color:#000;background-color:#bf6;padding:1px 1px;';
  
  if ($opcode === 'c') {
    $fragment = substr($from, $from_offset, $from_len);
    if (strlen($fragment) > 80) {
      echo htmlentities(htmlentities(substr($fragment, 0, 40)));
      echo '...<br /><br />...';
      echo htmlentities(htmlentities(substr($fragment, -40)));
    }
    else {
      echo htmlentities(htmlentities(substr($fragment, 0, 20)));
    }
  }
  elseif ($opcode === 'd') {
    $deletion = substr($from, $from_offset, $from_len);
    if (strcspn($deletion, " \n\r") === 0) {
      $deletion = str_replace(array("\n","\r"), array('\n','\r'), $deletion);
    }
    echo '<span style="' . $css_del . '">', htmlentities(htmlentities($deletion)), '</span>';
  }
  else /* if ( $opcode === 'i' ) */ {
    echo '<span style="' . $css_ins . '">', htmlentities(htmlentities(substr($from, $from_offset, $from_len))), '</span>';
  }
}

/**
 * Performs text wrapping
 * @param string $string
 *   Source string.
 * @param number $length
 *   Line length.
 * @param string $prefix
 *   Prefix for output lines.
 * @param string $break
 *   Break string for output lines.
 * @return string
 */
function regression_wrap_text($string, $length, $prefix, $break) {
  $string = preg_replace("/\r\n/", "\n", $string);
  $string = preg_replace("/([^\n]{" . (int)$length . "})/m", "$1\n", $string);
  $string = preg_replace("/([^\n]+)\n/", $prefix . '$1' . $break, $string);
  $string = preg_replace("/\n+/", "\n", $string);
  return $string;
}

/**
 * Renders diff in plain text format.
 * @param string $opcode
 * @param string $from
 * @param number $from_offset
 * @param number $from_len
 */
function regression_render_diff_opcode_text($opcode, $from, $from_offset, $from_len) {
  
  if ($opcode === 'c') {
    $fragment = substr($from, $from_offset, $from_len);
    if (strlen($fragment) > 70) {
      echo regression_wrap_text(drupal_html_to_text(substr($fragment, 0, 70)), 80, " [S] ", "\n");
      echo regression_wrap_text(drupal_html_to_text(substr($fragment, -70)), 80, " [S] ... ", "\n");
    }
    else {
      echo regression_wrap_text(drupal_html_to_text(substr($fragment, 0, 70)), 80, " [S] ", "\n");
    }
  }
  elseif ($opcode === 'd') {
    $deletion = substr($from, $from_offset, $from_len);
    if (strcspn($deletion, " \n\r") === 0) {
      $deletion = str_replace(array("\n","\r"), array('\n','\r'), $deletion);
    }
    echo regression_wrap_text(drupal_html_to_text($deletion), 80, "  [-] ", "\n");
  }
  else /* if ( $opcode === 'i' ) */ {
    echo regression_wrap_text(drupal_html_to_text(substr($from, $from_offset, $from_len)), 80, "  [+] ", "\n");
    echo "\n\n";
  }
}

/**
 * Generated HTML visualization of diff between two revisions.
 * @param RegressionRevision $old
 *   Old revision.
 * @param RegressionRevision $new
 *   New revision.
 */
function regression_diff_revisions(RegressionRevision $old = NULL, RegressionRevision $new, $use_html = TRUE) {
  module_load_include('php', 'regression', 'libraries/finediff/finediff');
  
  $diff = new FineDiff($old !== NULL ? $old->parser_value_plain_text : '', $new->parser_value_plain_text, FineDiff::$characterGranularity);
  
  ob_start();
  FineDiff::renderFromOpcodes($old !== NULL ? $old->parser_value_plain_text : '', $diff->getOpcodes(), $use_html ? 'regression_render_diff_opcode_html' : 'regression_render_diff_opcode_text');
  $diff_text = ob_get_clean();
  
  $diff_text = preg_replace('/\\x([a-fA-F0-9]{2})/', '&#$1;', $diff_text);
  
  return $diff_text;
}